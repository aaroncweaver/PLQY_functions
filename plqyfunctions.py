# -*- coding: utf-8 -*-
"""PLQYfunctions.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Gn5xRQ0lELDF3mpzUpHvLqUmGTXQaSL6
"""

def PLQYcorrection (Waves,glassLF,glassHF, LFPL, HFPL, Lowpower, Highpower, exlow = 315, exhigh = 520, emlow = 600, emhigh = 950, doprint = False, doplot = True, fulloutput = False, plottitle = ''):
    ##### INPUTS:
    ##### Waves = wavelengths(should be first column)
    ##### glassLF = low fluence glass measurement(where excitation is unsaturated)
    ##### glassHF = high fluence glass measurement(where excitation is saturated)
    ##### LFPL/HFPL = low/high fluence sample measurement(same laser power as glassLF/glassHF)
    ##### Lowpower/Highpower = laser power of low/high fluence measurements (units dont matter)

    ##### This function only fits a single spectrum

    baseline_samp = np.average(HFPL[:250]) ### corrects baseline of glass to match baseline of sample
    baseline_glass = np.average(glassHF[250])

    emcts = np.sum(HFPL[emlow:emhigh]) #creates matrix of 0s, this is the main difference between the 1 Sun and partial sun code
    excts = np.sum(LFPL[exlow:exhigh])
    if (doplot == True):
        fig = plt.figure(figsize = (10,6)) #size of figure
        plt.title(plottitle, fontsize = 25)
        plt.plot(Waves[:],glassHF[:]/baseline_glass*baseline_samp,'-',lw=1, color = 'blue')
        plt.plot(Waves[:],HFPL[:],'-',lw=1, color = 'red') ##plots sample and corrected glass

    glassex = np.sum(glassLF[exlow:exhigh])
    glassem = np.sum(glassHF[emlow:emhigh]/baseline_glass*baseline_samp)

    if (doplot == True): ### Creates and plots vertical lines to show integration area
        emlinehigh = Waves[emhigh]*np.ones(100)
        emlinelow = Waves[emlow]*np.ones(100)
        exlinehigh = Waves[exhigh]*np.ones(100)
        exlinelow = Waves[exlow]*np.ones(100)
        linebounds = np.logspace(0,3,100)
        plt.plot(emlinehigh,linebounds,'--',lw=1.5,color = 'cyan')
        plt.plot(emlinelow,linebounds,'--',lw=1.5,color = 'cyan')
        plt.plot(exlinehigh,linebounds,'--',lw=1.5,color = 'magenta')
        plt.plot(exlinelow,linebounds,'--',lw=1.5,color = 'magenta')
        plt.yscale('log')

    def correctedPLQY(emctshigh_samp, emctshigh_glass, exctslow_samp, exctslow_glass, highsuns, lowsuns):
        ratio = highsuns/lowsuns
        emdiff = emctshigh_samp-(emctshigh_glass)
        exdiff = exctslow_glass-exctslow_samp
        return emdiff/(exdiff*ratio)

    PLQY = (correctedPLQY(emctshigh_samp = emcts,emctshigh_glass = glassem,exctslow_samp = excts, exctslow_glass = glassex, highsuns = Highpower,lowsuns = Lowpower)) #this shows the PLQY for each of the measurements taken!!
    if (doprint == True):
        print(f'Excitation = {excts:.3e}, Emission = {emcts:.3e}, PLQY = {100*PLQY}')

    if (doplot == True):
        plt.show()

    if (fulloutput == True):
        return PLQY, emcts, excts, glassex, glassem
    return PLQY

def PLQYcorrection_fluencedep (Waves,glassLF,glassHF, LFPL, HFPL, Lowpower, Highpower, exlow = 315, exhigh = 520, emlow = 600, emhigh = 950, doprint = False, doplot = True,fulloutput = False, plottitle = ''):
    ##### INPUTS:
    ##### Waves = wavelengths(should be first column)
    ##### glassLF = low fluence glass measurement(where excitation is unsaturated)
    ##### glassHF = high fluence glass measurement(where excitation is saturated)
    ##### LFPL/HFPL = low/high fluence sample measurement(same laser power as glassLF/glassHF)
    ##### Lowpower/Highpower = laser power of low/high fluence measurements (units dont matter)

    ##### This analyzes multiple spectra at once -- glassHF, HFPL, and Highpower should be all of the data you want to analyze

    datasize = np.shape(HFPL)[1] # number of columns of high fluence data (you will end up with this many PLQY values)

    emcts = np.zeros(datasize) #Creates an array to store emission counts of each sample
    excts = np.sum(LFPL[exlow:exhigh]) #excitation counts of low fluence sample (we only care about low fluence for excitation)
    glassex = np.sum(glassLF[exlow:exhigh]) #excitation counts of low fluence glass

    baselinecorrection = np.zeros(datasize)

    if (doplot == True):
        fig = plt.figure(figsize = (10,6)) #size of figure
        plt.title(plottitle, fontsize = 25)

    for K in range(datasize):
        baselinecorrection[K] = np.average(HFPL[180:220,K])/np.average(glassHF[180:220,K]) #this is used to shift the glass data to match the sample data
        if (doplot == True):
            plt.plot(Waves[:],glassHF[:,K]*baselinecorrection[K],'-',lw=1)
            plt.plot(Waves[:],HFPL[:,K],'-',lw=1) #goes through each column and plots
        emcts[K] = np.sum(HFPL[emlow:emhigh,K]) #sums the values within the boundaries



    glassem = np.zeros(np.shape(glassHF)[1])
    for P in range(np.shape(glassHF)[1]):
        glassem[P] = np.sum(glassHF[emlow:emhigh,P])*baselinecorrection[P]




    if (doplot == True): ## this plots the vertical lines to show integration bounds
        emlinehigh = Waves[emhigh]*np.ones(100) #creates lines to show integration area of excitation/emission wavelengths
        emlinelow = Waves[emlow]*np.ones(100)
        exlinehigh = Waves[exhigh]*np.ones(100)
        exlinelow = Waves[exlow]*np.ones(100)
        linebounds = np.logspace(0,3,100) #y-values for lines
        plt.plot(emlinehigh,linebounds,'--',lw=1.5,color = 'cyan')
        plt.plot(emlinelow,linebounds,'--',lw=1.5,color = 'cyan')
        plt.plot(exlinehigh,linebounds,'--',lw=1.5,color = 'magenta')
        plt.plot(exlinelow,linebounds,'--',lw=1.5,color = 'magenta')
        plt.yscale('log')
        # plt.ylim(1,200)

    def correctedPLQY(emctshigh_samp, emctshigh_glass, exctslow_samp, exctslow_glass, highpower, lowpower):
        ratio = highpower/lowpower  ## this corrects for excitation oversaturation,
        emdiff = emctshigh_samp-(emctshigh_glass)
        exdiff = exctslow_glass-exctslow_samp
        return emdiff/(exdiff*ratio)


    PLQYS = (correctedPLQY(emctshigh_samp = emcts,emctshigh_glass = glassem,exctslow_samp = excts, exctslow_glass = glassex, highpower = Highpower,lowpower = Lowpower)) #this shows the PLQY for each of the measurements taken!!
    if (doprint == True):
        for K in range(datasize):
            print(f'Sample {K+1}, Emission = {emcts[K]:.3e}, PLQY = {100*PLQYS[K]}')

    if (doplot == True):
        plt.show()

    if (fulloutput == True): ## if true, returns excitation and emission counts --- leave false if you just want the PLQY
        return PLQYS, excts, emcts
    return PLQYS

def QY_ext_to_int (QY_ext, Pe = 0.125):  ## converts between external(measured) PLQY and internal PLQY
    ### Pe = probability of escape for emmited photon. This needs to be known. 12.5% is a literature estimate
    Qint = ((Pe/QY_ext)+1-Pe)**-1
    return Qint

def fluence_PLQY_fit_binr_fixK2(PLQY, G, Pe = 0.125, k1_bnd = (1e4,1e8), k2 = 2e-11, k3_bnd = (1e-31, 1e-27), p0_bnd = (1e11,1e15), X_bnd = (0.4,0.6)):
    ##### INPUTS:
    ##### PLQY = internal PLQY (use QY_ext_to_int function)
    ##### Pe probability of escape of emitted photon (need a good estimate)
    ##### k2 = bimolecular rate constant (this needs to be known/estimated)

    def cubic_roots(a,b,c,d):
        coeffs = np.array([a, b, c, d])
        roots = np.roots(coeffs)
        # print(roots)
        return np.max(np.real(roots))

    def PLQYfit_binr(G,Pe, k1, k2, k3, p0, X):
        datasize = np.size(G)
        n = np.zeros(datasize)
        for K in range(datasize):
            n[K] = cubic_roots(a = k3,b=k2*(X*Pe + 1- X),c=k1 + k2*(X*Pe + 1 - X)*p0,d = -1*G[K])
        p = n+p0
        PLQY = (X*k2*n*p)/(k1*n+k2*n*p+k3*n**3)
        return PLQY

    def Diff_Ev_Fit_PLQY(TRPL):

        def residuals(params):#params are the parameters to be adjusted by differential evolution or leastsq, interp is the data to compare to the model.
            #Variable Rates
            k1 = params[0]
            k3 = params[1]
            p0 = params[2]
            X = params[3]

            PLQY_sim = PLQYfit_binr(G,Pe, k1, k2, k3, p0,X)

            Resid= (np.sum(((PLQY_sim-PLQY)**2)/(PLQY_sim)))

            return (Resid) #returns the difference between the PL data and simulated data

        bounds = [k1_bnd, k3_bnd, p0_bnd, X_bnd]

        result = differential_evolution(residuals, bounds,x0 = [1e6,1e-29,2e13, 0.5])
        # print(result)
        return result.x

    p = Diff_Ev_Fit_PLQY(PLQY)

    k1 = p[0]
    k3 = p[1]
    p0 = p[2]
    X = p[3]


    PL_fit = PLQYfit_binr(G,Pe, k1, k2, k3, p0, X)

    return k1, k2, k3, p0,X, PL_fit